package lesson_8_Методы

/**
  * Тип результата иногда можно опускать, Scala определит его сама
  * У методов может быть несколько параметров
  * У методов может быть несколько списков параметров def plus(...)(...) = ...
  * У методов может вообще не быть параметров - это можно воспринимать, как переменную, которая будет вычисляться каждый раз при ее использовании
  * Если меод ничего не возвращает, то ставим тип Unit
  * Внутри метода можно объявлять другие методы и он может использовать параметры внешнего метода
  *
  * def sumAllTimes(u: Int, nums: Int*) = u * nums.sum - Последний параметр в списке параметров можт быть "повторяемый", тогда в теле метода его можно использовать как последовательность
  * def plus(x: Int, y: Int = 5) - значение параметра по умолчанию
  * При вызове метода plus(x = 3) можно явно указывать по имени параметра какое ему будет передаваться значение
  * def replaceNegative(x: Int, z: => Int): Int = if (x >= 0) x else z - если хотим, чтобы значение выражения вычислялось не всегда, можно использовать передачу "по имени", но если этот параметр упомянуть несколько раз, то и вычислится он несколько раз
  * Если список параметров содержит ровно один параметр, его значение можно передать блоком в фигурных скобках
  * Для рекурсивных функций обязательно нужно указывать тип
  * Если вызовы самой себя происходит только в "хвостовых точках" вычислений, функция может быть оптимизирована в "хвостовую рекурсию",
  *   которая внутри себя будет представлять цикл:
  *   def sumRange(from: Int, to: Int, acc: Int = 0): Int =
  *     if (to < from) acc
  *     else sumRange(from + 1, to, acc + from)
  */

object Main extends App {

  /**
    * Числа Фибоначчи
    */
  def fibs(num: Int): Int = {
    if (num == 1) 1
    else if (num == 2) 1
    else fibs(num - 1) + fibs(num - 2)
  }


}
